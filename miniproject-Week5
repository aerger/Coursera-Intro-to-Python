#
# Implementation of classic arcade game Pong
#
# -agf
# October 2014
# 
# This is the classic game of Pong, more or less, with a few
# bits of juice added, like shaking 'get ready' display, to
# allow the player a second (1.2 seconds, to be exact) to get
# ready for the ball to send when the game starts.
#
# ProTip: the paddles are movable during this time...
#
# There's also a pause mode to pause the game if you need a
# break. I have also implemented a super-deluxe "fancy ball"
# mode, which is about as groundbreaking as it sounds. ;)
# 
# The game rubric says the ball must fire immediately,
# but mine does not because I wanted the slight delay so
# the player could prepare for the ball to send. Didn't
# seem very fair otherwise. I hope peer evaluators understand
# that the game DOES run immediately when the play button
# in Codeskulptor is pressed, so the requirement IS
# satisfied; I just added a very purposeful delay to make
# the game more playable and fun.
#
# I try to comment these things a LOT. Hopefully it helps
# someone. :) Leave your username in the feedback if you
# have questions/comments about anything!
#
# I leave random string text all over the place in these
# projects... which is bad. You should totally gather all
# string text in one place so that any localisation you
# might need for your game down the road is easier. Not
# that THIS game will ever need it; which is why I didn't 
# bother cleaning it up.
#
# I wanted to add audio--it's actually pretty easy to 
# do--but didn't get around to it.
#
# ENJOY!  :)
#

# imports
import simplegui, random, math, time

# initialize globals here
WIDTH = 600
HEIGHT = 400       
BALL_RADIUS = 20
PAD_WIDTH = 8
PAD_HEIGHT = 80
HALF_PAD_WIDTH = PAD_WIDTH / 2
HALF_PAD_HEIGHT = PAD_HEIGHT / 2
LEFT = False
RIGHT = True
PAUSE = False
# Change FANCYBALL to True here if you want fancy-ball mode
# to be the default-on each time the program's executed:
FANCYBALL = False
score1 = 0
score2 = 0
ball_pos = [0,0]
ball_vel = [0,0]
paddle1_vel = 0
paddle2_vel = 0
paddle1_pos = 0
paddle2_pos = 0
# (that's a lot of globals, yeesh)

def spawn_ball(direction):
    """
    Initialize ball_pos and ball_vel for new ball
    in middle of table. 
    
    Direction input controls which direction the 
    ball is sent each time it's spawned; if direction
    is RIGHT, the ball's velocity is upper right, 
    else upper left.
    """
    
    global ball_pos, ball_vel # these are vectors stored as lists
    
    # timer delay launch of ball
    spawn.start()
    
    # ball starts out in the center of the screen
    ball_pos = [WIDTH/2,HEIGHT/2]
    
    # negate the velocity to switch X direction 
    # from right to left
    ball_vel[0] = (random.randrange(240, 360)/60.0)
    if direction == LEFT:
        ball_vel[0] = -ball_vel[0]
        
    # Y direction is always negative to spawn (upwards direction)
    # according to the project description/rubric
    ball_vel[1] = -(random.randrange(120, 240)/60.0)

# define event handlers
def new_game():
    """
    Initializes all the variables necessary for a clean restart
    of the game. 
    
    One thing I did NOT reset was the fancy-ball setting, so
    that players could choose their desired mode during gameplay
    and not have to constantly switch it back each time they
    restart. It of course resets each time the entire program 
    is executed.
    """
    
    global paddle1_pos, paddle2_pos, paddle1_vel, paddle2_vel  # these are numbers
    global score1, score2  # these are ints
    global ball_vel
    global PAUSE, FANCYBALL
    
    # reset scores, paddle data, ball velocity
    score1 = 0
    score2 = 0
    paddle1_vel = 0
    paddle2_vel = 0
    paddle1_pos = HEIGHT / 2
    paddle2_pos = HEIGHT / 2
    ball_vel = [0,0]
    # game starts out NOT paused
    PAUSE = False
    pausebutton.set_text('Pause')
    # uncomment these next two lines if you want the 
    # fancyball mode to reset to plain-ball every 
    # time you restart:
    #FANCYBALL = False
    #fancy_text()
    
    # start the game with a new ball
    spawn_ball(random.choice([RIGHT,LEFT]))

def draw_scores(canvas):
    """
    Draws the scores on the screen. I draw them twice,
    in white and black, offset, for better visual effect.
    """
    
    canvas.draw_text(str(score1).rjust(2, '0'), (PAD_WIDTH + 10, 40), 36, 'Black', 'monospace')
    canvas.draw_text(str(score2).rjust(2, '0'), (WIDTH - PAD_WIDTH - 50, 40), 36, 'Black', 'monospace')
    canvas.draw_text(str(score1).rjust(2, '0'), (PAD_WIDTH + 10 - 4, 40), 36, 'White', 'monospace')
    canvas.draw_text(str(score2).rjust(2, '0'), (WIDTH - PAD_WIDTH - 50 - 4, 40), 36, 'White', 'monospace')
    return   

def draw_ball(canvas):
    """
    Draws the ball. If fancy-ball mode is active, draws the additional
    fancy bits as well.
    """
    
    canvas.draw_circle([ball_pos[0],ball_pos[1]],BALL_RADIUS,2,'Yellow','Yellow')
    if FANCYBALL:
        canvas.draw_circle([ball_pos[0] - BALL_RADIUS/2, ball_pos[1] - BALL_RADIUS/3], 6, 2,'Black','White')
        canvas.draw_circle([ball_pos[0] + BALL_RADIUS/2, ball_pos[1] - BALL_RADIUS/3], 6, 2,'Black','White')
        canvas.draw_circle([ball_pos[0] - BALL_RADIUS/2, ball_pos[1] - BALL_RADIUS/3], 1, 1, 'Black','Black')
        canvas.draw_circle([ball_pos[0] + BALL_RADIUS/2, ball_pos[1] - BALL_RADIUS/3], 1, 1, 'Black','Black')
        canvas.draw_circle([ball_pos[0], ball_pos[1] + BALL_RADIUS/2], 6, 2, 'Red','Black') 
       
def draw(canvas):
    """
    The draw handler for the game. Where most of the magic happens.
    Commented more throughout.
    """
    
    global score1, score2, paddle1_pos, paddle2_pos, ball_pos, ball_vel

    # draw mid line and gutters of playfield
    canvas.draw_line([WIDTH / 2, 0],[WIDTH / 2, HEIGHT], 1, "White")
    canvas.draw_line([PAD_WIDTH, 0],[PAD_WIDTH, HEIGHT], 1, "White")
    canvas.draw_line([WIDTH - PAD_WIDTH, 0],[WIDTH - PAD_WIDTH, HEIGHT], 1, "White")
       
    #draw the ball
    draw_ball(canvas)
    
    # Is the game paused? Show a pause message and the scores
    if PAUSE:
        # draw scores; I want the scores present while
        # the game is paused, so player can change the 
        # ball appearance to fancy/plain as desired
        draw_scores(canvas)
        # flash our pause message by displaying it only on an interval
        if int(time.time()*10) % 3 <> 0:
            canvas.draw_text('P A U S E D', 
                             [(WIDTH - frame.get_canvas_textwidth('P A U S E D',36,'monospace'))/2, 
                              HEIGHT/2],36,'Black', 'monospace')
            canvas.draw_text('P A U S E D', 
                             [(WIDTH - 4 - frame.get_canvas_textwidth('P A U S E D',36,'monospace'))/2, 
                              HEIGHT/2 - 4],36,'White', 'monospace')
        # we're paused; get outta here
        return
    
    # while waiting for the ball to spawn, we disable ball updates
    if spawn.is_running():
        # waiting for ball to spawn, show a 'get ready' message    
        # SHAKE IT LIKE A POLAROID PICTURE
        gr_offset = random.randrange(6) - 3
        canvas.draw_text('G E T  R E A D Y', 
                         [(WIDTH - frame.get_canvas_textwidth('G E T  R E A D Y',36,'monospace'))/2, 
                          HEIGHT/2 + gr_offset],36,'Black', 'monospace')
        canvas.draw_text('G E T  R E A D Y',
                         [(WIDTH - 4 - frame.get_canvas_textwidth('G E T  R E A D Y',36,'monospace'))/2, 
                          HEIGHT/2 - 4 + gr_offset],36,'White', 'monospace')
    # we resume normal play here, as no pause or spawn in progress
    else:    
        # update ball
        # check for horizontal bounds (gutters, paddles)
        if (ball_pos[0] + ball_vel[0]) >= (WIDTH - BALL_RADIUS - PAD_WIDTH - 1):
            # are we bumping into the right paddle -- take action if so
            if (paddle2_pos + HALF_PAD_HEIGHT >= ball_pos[1] >= paddle2_pos - HALF_PAD_HEIGHT):
                ball_vel[0] = -ball_vel[0]   
                ball_vel[0] *= 1.1
                ball_vel[1] *= 1.1
            # looks like we just hit the gutter, so update the score
            # and fire the ball away
            else:
                score1 += 1
                spawn_ball(LEFT)
        elif (ball_pos[0] + ball_vel[0]) <= (BALL_RADIUS + PAD_WIDTH):
            # are we bumping into the left paddle -- take action if so
            if (paddle1_pos + HALF_PAD_HEIGHT >= ball_pos[1] >= paddle1_pos - HALF_PAD_HEIGHT):
                ball_vel[0] = -ball_vel[0]
                ball_vel[0] *= 1.1
                ball_vel[1] *= 1.1
            # looks like we just hit the gutter, so update the score
            # and fire the ball away
            else:
                score2 += 1
                spawn_ball(RIGHT)
        else:
            ball_pos[0] += ball_vel[0]
            
        # check for vertical bounds (top/bottom)
        if (ball_pos[1] + ball_vel[1]) >= (HEIGHT - BALL_RADIUS - 1):
            ball_pos[1] = HEIGHT - BALL_RADIUS - 1
            ball_vel[1] = - ball_vel[1]
        elif (ball_pos[1] + ball_vel[1]) <= (BALL_RADIUS):
            ball_pos[1] = BALL_RADIUS
            ball_vel[1] = - ball_vel[1]
        else:    
            ball_pos[1] += ball_vel[1]
    
    # update paddle's vertical position, keep paddle on the screen
    # paddle1 (left)
    if paddle1_pos + paddle1_vel >= HEIGHT - HALF_PAD_HEIGHT - 1:
        paddle1_pos = HEIGHT - HALF_PAD_HEIGHT
    elif paddle1_pos + paddle1_vel <= HALF_PAD_HEIGHT:
        paddle1_pos = HALF_PAD_HEIGHT
    else:
        paddle1_pos += paddle1_vel
        
    # paddle2 (right)
    if paddle2_pos + paddle2_vel >= HEIGHT - HALF_PAD_HEIGHT - 1:
        paddle2_pos = HEIGHT - HALF_PAD_HEIGHT
    elif paddle2_pos + paddle2_vel <= HALF_PAD_HEIGHT:
        paddle2_pos = HALF_PAD_HEIGHT
    else:
        paddle2_pos += paddle2_vel
    
    # draw paddles
    # paddle1 (left)
    canvas.draw_line([PAD_WIDTH - HALF_PAD_WIDTH - 1, paddle1_pos - HALF_PAD_HEIGHT], 
                     [PAD_WIDTH - HALF_PAD_WIDTH - 1, paddle1_pos + HALF_PAD_HEIGHT],
                     PAD_WIDTH, 'White')
    # paddle2 (right)
    canvas.draw_line([WIDTH - PAD_WIDTH + HALF_PAD_WIDTH + 1, paddle2_pos - HALF_PAD_HEIGHT], 
                     [WIDTH - PAD_WIDTH + HALF_PAD_WIDTH + 1, paddle2_pos + HALF_PAD_HEIGHT],
                     PAD_WIDTH, 'White')
    
    # draw scores
    # this is a second draw call; the first call happens in 
    # pause mode, so we need to do it again here to ensure
    # it's layered properly with everything else being displayed
    draw_scores(canvas)
    
def keydown(key):
    """
    Check for key-DOWN events that affect both the left and right
    paddles. W and S for left player (player 1) up and down,
    respectively; up-arrow and down-arrow for right player
    (player 2), respectively.
    
    The key handling in this isn't great; I consider it a limitation
    of Codeskulptor not being able to poll pressed keys directly;
    sure, I could code around it, but I shouldn't have to, and
    the rubric clearly says to test each key "in isolation" anyway.
    
    I choose a paddle speed of 5 here because that felt right.
    The rubric makes no particular demands in this regard.
    """
    
    global paddle1_vel, paddle2_vel

    #paddle1 (left)
    if key == simplegui.KEY_MAP['s']:
        paddle1_vel += 5
    elif key == simplegui.KEY_MAP['w']:
        paddle1_vel -= 5
    
    #paddle2 (right)
    if key == simplegui.KEY_MAP['down']:
        paddle2_vel += 5
    elif key == simplegui.KEY_MAP['up']:
        paddle2_vel -= 5
    
def keyup(key):
    """
    Releasing a key resets the speed of the paddle to zero
    for whatever player paddle the key belongs to, stopping
    the movement of the paddle.
    """
    
    global paddle1_vel, paddle2_vel

    # paddle1 (left)
    if key == simplegui.KEY_MAP['s']:
        paddle1_vel = 0
    elif key == simplegui.KEY_MAP['w']:
        paddle1_vel = 0
    
    # paddle2 (right)
    if key == simplegui.KEY_MAP['down']:
        paddle2_vel = 0
    elif key == simplegui.KEY_MAP['up']:
        paddle2_vel = 0

def spawner():
    """
    Shuts down our ballspawn timer immediately 
    so it doesn't keep triggering.
    """
    
    spawn.stop()

def pause():
    """
    This toggles the pause state of the game,
    as well as the pause/resume button text.
    
    Could have broken this text display out like
    I did for fancy_text/fancyball(), but it
    felt like overkill for a single button text
    change.
    """
    
    global PAUSE
    
    PAUSE = not(PAUSE)
    if PAUSE:
        pausebutton.set_text('Resume')
    else:
        pausebutton.set_text('Pause')
        spawn.start()

def fancy_text():
    """
    Update the fancy-ball toggle button text, as
    well as the helper text below the button to 
    better indicate the current mode as indicated
    by the value of FANCYBALL (True or False).
    """
    
    if FANCYBALL:
        fancybutton.set_text('Plain Ball')
        fancylabel.set_text('FANCY ball selected!')       
    else:
        fancybutton.set_text('Fancy Ball')
        fancylabel.set_text('Plain ball selected.')

def fancyball():
    """
    Toggles fancy-ball mode on/off, updates
    the display of the toggle button text and helper
    text below the button.
    """
    
    global FANCYBALL
    
    FANCYBALL = not(FANCYBALL)
    fancy_text()
    
# create frame and all the stuff that goes with it
frame = simplegui.create_frame("Pong", WIDTH, HEIGHT)
frame.set_canvas_background('#505050')
frame.add_label('P O N G: The Game')
frame.add_label('Plays forever. No quarters!')
frame.add_label('')
# Restart button
frame.add_button('Restart', new_game, 100)
frame.add_label('')
# Pause button
pausebutton = frame.add_button('Pause', pause, 100)
# whitespace to offset fancy-mode stuff
frame.add_label('')
frame.add_label('')
frame.add_label('')
frame.add_label('')
frame.add_label('')
frame.add_label('')
frame.add_label('')
# fancy mode UI stuff
frame.add_label("Optional 'fancy ball' mode")
frame.add_label('(survives game restarts):')
fancybutton = frame.add_button('', fancyball, 100)
fancylabel = frame.add_label('')
fancy_text()

# timers
# controls duration of "get ready" ball-spawn message
spawn = simplegui.create_timer(1200, spawner)

# handlers
frame.set_draw_handler(draw)
frame.set_keydown_handler(keydown)
frame.set_keyup_handler(keyup)

# start the game, start the frame
# after this, nothing's the same
new_game()
frame.start()

# END #################
